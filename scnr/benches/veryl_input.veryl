module Module01 {
    // integer
    const a : u32 = 0123456789;
    const aa: u32 = 01234_56789;

    // binary
    const b  : u32 = 32'b01xzXZ;
    const bb : u32 = 32'b01_xz_XZ;
    const bbb: u32 = 32'sb01_xz_XZ;

    // octal
    const c  : u32 = 32'o01234567xzXZ;
    const cc : u32 = 32'o01234_567xzXZ;
    const ccc: u32 = 32'so01234_567xzXZ;

    // decimal
    const d  : u32 = 32'd0123456789;
    const dd : u32 = 32'd01234_56789;
    const ddd: u32 = 32'sd01234_56789;

    // hex
    const e  : u32 = 128'h0123456789abcdefxzABCDEFXZ;
    const ee : u32 = 128'h01234_5678_9abc_defxz_ABCD_EFXZ;
    const eee: u32 = 128'sh01234_5678_9abc_defxz_ABCD_EFXZ;

    // all0, all1, allx, allz
    const f     : u32 = '0;
    const ff    : u32 = '1;
    const fff   : u32 = 'x;
    const ffff  : u32 = 'X;
    const fffff : u32 = 'z;
    const ffffff: u32 = 'Z;

    // floating point
    const g    : u32 = 0123456789.0123456789;
    const gg   : u32 = 0123456789.0123456789e+0123456789;
    const ggg  : u32 = 0123456789.0123456789e-0123456789;
    const gggg : u32 = 0123456789.0123456789E+0123456789;
    const ggggg: u32 = 0123456789.0123456789E-0123456789;
}
module Module02 {
    // unsigned integer
    let _a : u32 = 1;
    let _aa: u64 = 1;

    // signed integer
    let _b : i32 = 1;
    let _bb: i64 = 1;

    // floating point
    let _c : f32 = 1;
    let _cc: f64 = 1;

    // 4 state (01xz) type
    let _d  : logic         = 1;
    let _dd : logic<10>     = 1;
    let _ddd: logic<10, 10> = 1;

    // 2 state (01) type
    let _e  : bit         = 1;
    let _ee : bit<10>     = 1;
    let _eee: bit<10, 10> = 1;

    // array
    let _f     : u32 [10] = 1;
    let _ff    : u64 [10] = 1;
    let _fff   : i32 [10] = 1;
    let _ffff  : i64 [10] = 1;
    let _fffff : f32 [10] = 1;
    let _ffffff: f64 [10] = 1;
}
module Module03 {
    // unary arithmetic
    let _a : logic = +1;
    let _aa: logic = -1;

    // unary logical
    let _b : logic = !1;
    let _bb: logic = ~1;

    // unary reduce
    let _c      : logic = &1;
    let _cc     : logic = |1;
    let _ccc    : logic = ^1;
    let _cccc   : logic = ~&1;
    let _ccccc  : logic = ~|1;
    let _cccccc : logic = ~^1;
    let _ccccccc: logic = ^~1;

    // binary arithmetic
    let _d     : logic = 1 ** 1;
    let _dd    : logic = 1 * 1;
    let _ddd   : logic = 1 / 1;
    let _dddd  : logic = 1 % 1;
    let _ddddd : logic = 1 + 1;
    let _dddddd: logic = 1 - 1;

    // binary shift
    let _e   : logic = 1 << 1;
    let _ee  : logic = 1 >> 1;
    let _eee : logic = 1 <<< 1;
    let _eeee: logic = 1 >>> 1;

    // binary compare
    let _f         : logic = 1 <: 1;
    let _ff        : logic = 1 <= 1;
    let _fff       : logic = 1 >: 1;
    let _ffff      : logic = 1 >= 1;
    let _fffff     : logic = 1 == 1;
    let _ffffff    : logic = 1 != 1;
    let _fffffff   : logic = 1 === 1;
    let _ffffffff  : logic = 1 !== 1;
    let _fffffffff : logic = 1 ==? 1;
    let _ffffffffff: logic = 1 !=? 1;

    // binary bitwise
    let _g    : logic = 1 & 1;
    let _gg   : logic = 1 ^ 1;
    let _ggg  : logic = 1 ~^ 1;
    let _gggg : logic = 1 ^~ 1;
    let _ggggg: logic = 1 | 1;

    // binary logical
    let _h : logic = 1 && 1;
    let _hh: logic = 1 || 1;
}
// module declaration
module Module04 #(
    // module parameter
    param a  : u32  = 1        ,
    const aa : u32  = 1        ,
    const aaa: type = logic<10>,
) (
    // module port
    b    : input  logic    <10>,
    bb   : output logic    <10>,
    bbb  : inout  tri logic<10>,
    bbbb : interface,
    bbbbb: modport Interface04::d,
) {
    // localparam declaration
    const c : u32 = 1;
    const cc: u64 = 1;

    // variable declaration
    let _d  : logic         = 1;
    let _dd : logic<10>     = 1;
    let _ddd: bit  <10, 10> = 1;

    assign bb  = 0;
    assign bbb = 0;
}

interface Interface04 {
    var c: logic;

    modport d {
        c: input,
    }
}
// interface declaration
interface Interface05 #(
    // interface parameter
    param a  : u32 = 1,
    param aa : u32 = 1,
    const aaa: u32 = 1,
) {
    // localparam declaration
    const b : u32 = 1;
    const bb: u64 = 1;

    // variable declaration
    var c  : logic            ;
    var cc : logic    <10>    ;
    var ccc: tri logic<10, 10>;

    // modport declaration
    modport d {
        c  : input ,
        cc : output,
        ccc: inout ,
    }
}
module Module06 {
    const ParamX: u32 = 1;

    // function without parameter
    function FuncA (
        a: input  logic<ParamX>,
        b: output logic<ParamX>,
        c: ref    logic<ParamX>,
    ) -> logic<ParamX> {
        let d: u32 = 1;
        b = a + 1 + d;
        c = a / 1;
        return a + 2;
    }

    // void function
    function FuncC (
        a: input logic<ParamX>,
        c: ref   logic<ParamX>,
    ) {
        c = a / 1;
    }

    let a: logic<ParamX> = 1;
    var b: logic<ParamX>;
    var c: logic<ParamX>;
    var d: logic<ParamX>;
    var e: logic<ParamX>;
    var f: logic<ParamX>;

    // function call
    assign d = FuncA(a, b, c);

    // void function call
    initial {
        FuncC(a, e);
    }

    // system function call
    assign f = $clog2(a);
}
module Module07 {
    var a  : logic;
    var aa : logic;
    let clk: clock = 1;

    always_comb {
        // assignment statement
        a =    1;
        a +=   1;
        a -=   1;
        a *=   1;
        a /=   1;
        a %=   1;
        a &=   1;
        a |=   1;
        a ^=   1;
        a <<=  1;
        a >>=  1;
        a <<<= 1;
        a >>>= 1;

        // if statement
        if a {
            a  = 1;
            aa = 1;
        } else if a {
            a  = 1;
            aa = 1;
        } else {
            a  = 1;
            aa = 1;
        }

        // for statement
        for i: u32 in 0..10 {
            a  = i;
            aa = i + 1;
        }

        // for statement with closed range
        for i: u32 in 0..=10 {
            a  = i;
            aa = i + 1;
        }

        // for statement with custom step
        for i: u32 in 0..10 step += 2 {
            a  = i;
            aa = i + 1;
        }
        for i: u32 in 0..10 step *= 2 {
            a  = i;
            aa = i + 1;
        }

        // for statement with break statement
        for i: u32 in 0..10 {
            a  = i;
            aa = i + 1;
            if i == 0 {
                break;
            }
        }

        for i: u32 in 0..10 {
            for j: u32 in 0..10 {
                a  = i;
                aa = i + j;
                if i == 0 && j == 0 {
                    break;
                }
            }
        }
    }

    always_ff (clk) {
        a +=   1;
        a -=   1;
        a *=   1;
        a /=   1;
        a %=   1;
        a &=   1;
        a |=   1;
        a ^=   1;
        a <<=  1;
        a >>=  1;
        a <<<= 1;
        a >>>= 1;
    }
}
module Module08 {
    const a    : u32   = 1;
    const b    : u32   = 1;
    let i_clk: clock = 1;

    // if declaration
    if a == 1 :label {
        var a: logic;
        always_ff (i_clk) {
            a = 1;
        }
    } else if b == 1 { // label can be omit in else clause
        var a: logic;
        always_ff (i_clk) {
            a = 1;
        }
    } else if b == 1 :label1 { // label can be override in the specified clause only
        var a: logic;
        always_ff (i_clk) {
            a = 1;
        }
    } else {
        var a: logic;
        always_ff (i_clk) {
            a = 1;
        }
    }

    // for declaration
    for i in 0..10 :label2 {
        var a: logic;
        always_ff (i_clk) {
            a = i;
        }
    }

    // for declaration with custom step
    for i in 0..10 step += 2 :label3 {
        var a: logic;
        always_ff (i_clk) {
            a = i;
        }
    }
}
module Module09 {
    // struct declaration
    struct A {
        a  : logic<10>,
        aa : logic<10>,
        aaa: u32      ,
    }

    // enum declaration
    enum B: logic<2> {
        X = 1,
        Y = 2,
        Z,
    }

    enum C {
        X = 2,
        Y = 3,
        Z,
    }

    enum D {
        X,
    }

    #[enum_encoding(sequential)]
    enum E {
        X,
        Y,
        Z,
    }

    #[enum_encoding(onehot)]
    enum F {
        X,
        Y,
        Z,
    }

    #[enum_encoding(gray)]
    enum G {
        X,
        Y,
        Z,
    }

    #[enum_member_prefix(FOO)]
    enum H: logic {
        H_0,
        H_1,
    }

    var a: A    ;
    var b: B    ;
    var c: C    ;
    var d: D    ;
    var e: E    ;
    var f: F    ;
    var g: G    ;
    var h: H    ;
    var i: logic;

    assign a.a   = 1;
    assign a.aa  = 1;
    assign a.aaa = 1;
    assign b     = B::X;
    assign c     = C::X;
    assign d     = D::X;
    assign e     = E::X;
    assign f     = F::X;
    assign g     = G::X;
    assign h     = H::H_0;
    assign i     = a.a;
}
module //a
 Module10 //a
 (
    i_clk // a
    : // a
     input //a
     clock //a
    ,
    i_rst: input reset,
    i_up : input logic,

    i_down : input  logic   ,
    o_count: output logic<8>,
) {
    var count //a
    : logic //a
    < // a
    8 //a
    > // a
    ;
    var up_down: logic<2>;

    assign o_count = count;

    always_comb // a
     {
        up_down = // a
         (i_up // a
         << //a
         1) // a
         | i_down;
    }

    always_ff // a
     (i_clk // a
    , // a
     i_rst // a
    ) // a
     {
        if_reset // a
         {
            count = 0;
        } // a
         else //
         if // a
         up_down // a
         == // a
         2'b10 {
            count = count // a
             + 1 //a
            ;
        } // a
         else // a
         if //a
         up_down == 2'b01 {
            count // a
             = count - // a
             1;
        }
    }
}
module Module11 {
    // variable declaration
    var b   : logic        ;
    var bb  : logic<10>    ;
    let _bbb: bit  <10, 10> = 1;

    // variable declaration with assignment
    let _c: logic<10> = 1;

    // assign declaration
    assign b  = 1;
    assign bb = 1;
}
module Module12_1 (
    i_clk: input clock,
    i_rst: input reset,
) {
    var a: logic;
    var b: logic;
    var c: logic;

    always_ff (i_clk) {
        if_reset {
            c = 0;
        } else {
            c = ~a;
        }
    }

    always_ff {
        if_reset {
            a = 0;
        } else {
            a = ~a;
        }
    }

    always_ff {
        b = a;
    }
}

module Module12_2 (
    i_clk   : input `_ clock           ,
    i_clk_p : input `_ clock_posedge   ,
    i_clk_n : input `_ clock_negedge   ,
    i_rst   : input `_ reset           ,
    i_rst_ah: input `_ reset_async_high,
    i_rst_al: input `_ reset_async_low ,
    i_rst_sh: input `_ reset_sync_high ,
    i_rst_sl: input `_ reset_sync_low  ,
) {
    var a : logic;
    var aa: logic;
    let b : logic = 1;
    let c : logic = 1;

    // always_ff declaration with default polarity
    always_ff (i_clk, i_rst) {
        if_reset {
            a = 1'b0;
        } else if a {
            a = b[0];
        } else {
            a = c[5:0];
        }
    }

    // always_ff declaration without reset
    always_ff (i_clk) {
        if a {
            a = b;
        } else {
            a = c[5:0];
        }
    }

    // always_ff declaration with specified polarity
    always_ff (i_clk_p, i_rst_ah) {
        if_reset {
            a = 1'b0;
        } else {
            a = c[5:0];
        }
    }
    always_ff (i_clk_n, i_rst_al) {
        if_reset {
            a = 1'b0;
        } else {
            a = c[5:0];
        }
    }
    always_ff (i_clk_p, i_rst_sh) {
        if_reset {
            a = 1'b0;
        } else {
            a = c[5:0];
        }
    }
    always_ff (i_clk_n, i_rst_sl) {
        if_reset {
            a = 1'b0;
        } else {
            a = c[5:0];
        }
    }

    // if_reset with loop
    var d: logic<10>;
    for i in 0..10 :g {
        always_ff (i_clk, i_rst) {
            if_reset {
                d[i] = i;
            }
        }
    }

    // if_reset with loop
    var e: logic<10>;
    always_ff (i_clk, i_rst) {
        if_reset {
            for i: u32 in 0..10 {
                e[i] = i;
            }
        }
    }

    // always_comb declaration
    always_comb {
        a    = 10;
        aa   = 10'b0;
        aa.a = 10'b01z;

        a  = 10 + 10;
        aa = 10 + 16'hffff * (3 / 4);
    }
}
module Module13 {
    var a: logic;
    var b: logic;
    var c: logic;
    var d: logic;
    var e: logic;
    let X: logic = 1;

    // bit select
    assign a = X[0];

    // range select
    assign b = X[1:0];

    // position and width
    assign c = X[1+:2];
    assign d = X[1-:2];

    // index by step
    assign e = X[1 step 2];
}
module Module14 {
    const X: u32 = 1;

    let a  : logic = 1;
    let aa : logic = 1;
    let bbb: logic = 1;

    // module instantiation
    inst x: Module14B;

    // module instantiation with parameter and port
    inst xx: Module14C #(
        X    ,
        Y: 10,
    ) (
        a        ,
        bb  : aa ,
        bbbb: bbb,
    );

    // interface instantiation
    inst y: InterfaceA;

    // interface instantiation with parameter
    inst yy : InterfaceA #(a, b: 10,);
    inst xxx: InterfaceA #(a, b: 10,);

    // interface array
    inst yyy: InterfaceA [10];
}

module Module14B {}

module Module14C #(
    param X: u32 = 1,
    param Y: u32 = 1,
) (
    a   : input u32,
    bb  : input u32,
    bbbb: input u32,
) {}

interface InterfaceA #(
    param a: u32 = 1,
    param b: u32 = 1,
) {}
module Module15 {
    let _a: logic = 1;

    :label {
        let _a: logic = 1;
    }

    :label1 {
        let _a: logic = 1;
    }

    for i in 0..10 :label2 {
        :label {
            let _a: logic = 1;
        }
    }
}
module Module16 {
    const y: bit = 1;

    var a: logic   ;
    var b: logic   ;
    let x: logic    = 1;
    let z: logic<3> = 1;

    always_comb {
        case x {
            0: a = 1; // comment
            1: a = 1; // comment
            2: { // comment
                   a = 1; // comment
                   a = 1;
                   a = 1;
               } //
            3, 4   : a = 1;
            5..=7  : a = 1;
            y - 1  : a = 1;
            default: a = 1;
        }
    }

    always_comb {
        switch {
            z == 0: b = 1;
            z == 1: b = 1;
            z == 2: {
                        b = 1;
                        b = 1;
                        b = 1;
                    } //
            z == 3, z == 4: b = 1;
            default       : b = 1;
        }
    }
}
package Package17 {
    // localparam declaration
    const ParamX: u32 = 1;

    // variable declaration
    var _b: logic;

    // struct declaration
    struct A {
        a  : logic<10>,
        aa : logic<10>,
        aaa: u32      ,
    }

    // enum declaration
    enum B: logic<2> {
        X = 1,
        Y = 2,
        Z,
    }

    // function declaration
    function FuncA (
        a: input  logic<ParamX>,
        b: output logic<ParamX>,
        c: ref    logic<ParamX>,
    ) -> logic<ParamX> {
        let d: u32 = 1;
        b = a + 1 + d;
        c = a / 1;
        return a + 2;
    }
}
module Module18 {
    var a: logic;
    var b: logic;
    let c: logic = 1;

    assign a = {a[10:0], c,};
    assign b = {a[10:0] repeat 10, c repeat 4};
}
import $sv::PackageA::A;
import $sv::PackageA::*;

package PackageA {
    const A: u32 = 0;
}

module Module19 {
    import PackageA::A;
    import PackageA::*;
}

interface Interface19 {
    import PackageA::A;
    import PackageA::*;
}

package Package19 {
    import PackageA::A;
    import PackageA::*;
    export PackageA::A;
    export *;
}
module Module20 {
    var a: logic;
    var b: logic;
    var c: logic;
    let x: logic = 1;
    let y: logic = 1;

    assign a = if x {
        1
    } else {
        if y {
            1
        } else {
            2
        }
    };

    assign b = case a {
        1      : 0,
        2      : 1,
        3, 4   : 2,
        5..=7  : 3,
        default: 4,
    };

    assign c = switch {
        a == 1        : 0,
        a == 2        : 1,
        a == 3, a == 4: 2,
        default       : 3,
    };
}
module Module21 {
    var a: logic   ;
    var b: logic<2>;
    let c: logic    = 1;

    enum EnumA: logic {
        A,
        B,
    }

    enum EnumB: logic {
        C,
        D,
    }

    const EnumC: type = EnumB;

    const EnumD: u32 = 1;

    assign a = (((c as EnumA) as EnumB) as EnumC) as EnumD;
    assign b = c as 2;
}
module Module22 {
    let _a: signed logic    <10> = 1;
    let _b: tri signed logic<10> = 1;
    let _c: signed tri logic<10> = 1;
    let _d: logic           <10> = 1;
}
module Module23 #(
    #[ifdef(DEFINE_A)]
    #[ifdef(DEFINE_B)]
    #[ifdef(DEFINE_C)]
    #[ifdef(DEFINE_D)]
    param ParamA: u32 = 1,
    param ParamB: u32 = 1,
    #[ifdef(DEFINE_A)]
    {
        param ParamC: u32 = 1,
    },
) (
    #[ifdef(DEFINE_A)]
    port_a: input logic,
    port_b: input logic,

    #[ifdef(DEFINE_A)]
    {
        port_c: input logic,
    },
) {
    #[ifdef(DEFINE_A)]
    #[ifdef(DEFINE_B)]
    let _a: logic<10> = 1;

    #[ifdef(DEFINE_A)]
    {
        let _b: logic<10> = 1;
        let _c: logic<10> = 1;
    }

    var _d: logic;
    always_comb {
        #[ifdef(DEFINE_D)]
        {
            _d = 0;
        }
    }
}

#[ifdef(DEFINE_A)]
module Module23_A {}

#[ifndef(DEFINE_A)]
{
    module Module23_B {}
    module Module23_C {}
}
module Module24 {
    #[sv("ram_style=\"block\"")]
    let _a: logic = 1;
    #[sv("mark_debug=\"true\"")]
    let _b: logic = 1;
}
module Module25 (
    i_clk : input   clock                         ,
    i_rst : input   reset                         ,
    in_if : modport veryl_sample3::data_if::mp_in ,
    out_if: modport veryl_sample3::data_if::mp_out,
) {
    inst data_if: veryl_sample3::data_if;

    inst u0: veryl_sample1::delay (
        i_clk                ,
        i_rst_n: i_rst       ,
        i_d    : in_if.data  ,
        o_d    : data_if.data,
    );

    inst u1: veryl_sample2::delay (
        i_clk                ,
        i_rst_n: i_rst       ,
        i_d    : data_if.data,
        o_d    : out_if.data ,
    );
}
module Module26 {
    let _a: logic<10>              = 1;
    let _b: logic<10, 10>          = 1;
    let _c: logic<10, 10> [10]     = 1;
    let _d: logic<10, 10> [10, 10] = 1;
}
module Module27 {
    const a: string = "aaa";

    let _b: string = "bbb";
}
module Module28A (
    c: input logic<30, 40>,
) {
    const WIDTH0: u32 = 10;
    const WIDTH1: u32 = 20;

    let a: logic<10, 20>              = 1;
    let b: logic<WIDTH0 + 10, WIDTH1> = 1;

    let _x: logic = a[msb][msb:lsb + 1];
    let _y: logic = b[msb - 3][msb + 5:lsb];
    let _z: logic = c[msb][msb];
}

package Package28A::<W: const> {
    struct StructA {
        a: logic<W>,
    }
}

package Package28B {
    const B: u32 = 2;
}

package Package28C {
    const W: u32       = 2;
    const N: u32       = 3;
    const C: bit<N, W> = 0;
}

module ModuleB {
    var a  : Package28A::<Package28B::B>::StructA;
    assign a.a = 0;

    let _w: logic = a[msb];
    let _x: logic = a.a[msb];
    let _y: logic = Package28C::C[msb];
    let _z: logic = Package28C::C[0][msb];
}
module Module29 (
    clk: input clock,
    rst: input reset,
) {
    var a: logic;
    var b: logic;
    #[allow(unused_variable)]
    let c: logic = 1;

    #[allow(missing_reset_statement)]
    always_ff (clk, rst) {
        if_reset {
            a = 0;
        } else {
            a = 0;
            b = 0;
        }
    }

    #[allow(missing_port)]
    inst u0: Module29 (


    );
}

module Module31 {
    initial {
        $display("initial");
    }

    final {
        $display("final");
    }
}
module Module32 {
    var a: logic;
    var b: logic;

    assign a = inside 1 + 2 / 3 {0, 0..10, 1..=10};
    assign b = outside 1 * 2 - 1 {0, 0..10, 1..=10};
}
module Module33 {
    const a0: u32 = 'b1;
    const a1: u32 = 'b1010;
    const a2: u32 = 'o1;
    const a3: u32 = 'o1234;
    const a4: u32 = 'd1;
    const a5: u32 = 'd12345678;
    const a6: u32 = 'h1;
    const a7: u32 = 'hffffffff;
    const a8: u32 = 'hffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff;
}
module Module34 {
    const a0: u32 = '0;
    const a1: u32 = '1;
    const a2: u32 = 'x;
    const a3: u32 = 'z;
    const a4: u32 = 10'0;
    const a5: u32 = 10'1;
    const a6: u32 = 10'x;
    const a7: u32 = 10'z;
}
module Module35 {
    let aa: logic = 1;

    inst xx: Module35B (
        aa     ,
        bb  : _,
        bbbb: _,
    );
}

module Module35B (
    aa  : input  u32,
    bb  : output u32,
    bbbb: output u32,
) {
    always_comb {
        bb   = 0;
        bbbb = 0;
    }
}
/// Test module for doc comment
///
/// * list item0
/// * list item1
///
/// ```wavedrom
/// {signal: [
///   {name: 'clk', wave: 'p.....|...'},
///   {name: 'dat', wave: 'x.345x|=.x', data: ['head', 'body', 'tail', 'data']},
///   {name: 'req', wave: '0.1..0|1.0'},
///   {},
///   {name: 'ack', wave: '1.....|01.'}
///
/// ]}
/// ```
///
/// ```mermaid
/// graph TD;
///     A-->B;
///     A-->C;
///     B-->D;
///     C-->D;
/// ```
///
pub module Module36 #(
    /// Data width
    param ParamA: u32 = 1,
    const ParamB: u32 = 1,
) (
    i_clk  : input  logic        , /// Clock
    i_rst_n: input  logic        , /// Reset
    i_data : input  logic<ParamA>, /// Data input
    o_data : output logic<ParamA>, /// Data output
) {
    assign o_data = 0;
}

/// Test interface for doc comment
///
/// * list item0
/// * list item1
pub interface Interface36 #(
    param ParamA: u32 = 1, /// Data width
    const ParamB: u32 = 1,
) {}

/// Test package for doc comment
///
/// * list item0
/// * list item1
pub package Package36 {}
package Package37 {
    const A: u32 = 1;

    enum B: logic {
        C,
    }

    function X -> u32 {
        return 0;
    }
}

module Module37 {
    let _a: u32 = Package37::A;
    let _b: u32 = Package37::B::C;
    let _c: u32 = Package37::X();
}
module Module38 {
    type word_t    = logic <16>         ;
    type words_t   = logic <16, 16>     ;
    type regfile_t = word_t         [16];

    type octbyte = bit<8> [8];

    var rf   : regfile_t;
    assign rf[0] = '0;
}

interface Interface38 {
    type word_t    = logic <16>         ;
    type words_t   = logic <16, 16>     ;
    type regfile_t = word_t         [16];

    type octbyte = bit<8> [8];
}

package Package38 {
    type word_t    = logic <16>         ;
    type words_t   = logic <16, 16>     ;
    type regfile_t = word_t         [16];

    type octbyte = bit<8> [8];
}
module Module39 (
    mst: modport Interface39::master,
    slv: modport Interface39::slave ,
) {
    var a    : logic;
    assign mst.a = a;
    assign a     = slv.get_a();
}

interface Interface39 {
    var a: logic;

    function get_a () -> logic {
        return a;
    }

    modport master {
        a: output,
    }

    modport slave {
        a    : input ,
        get_a: import,
    }
}
module Module40 {

    enum EnumA: logic<2> {
        member_a,

        member_b,
        member_c = 3,
    }

    var a: EnumA;

    assign a = EnumA::member_a;
    function is_a (
        e: input EnumA,
    ) -> logic {
        return e == EnumA::member_a;
    }
}
module Module41 {
    enum Boolean: logic {
        True = 1,
        False = 0,
    }

    union A {
        b: logic  ,
        c: Boolean,
    }

    var foo  : A;
    assign foo.b = 1'b0;

    var bar  : A;
    assign bar.c = Boolean::True;
}
module Module42 (
    i_clk  : input  logic,
    i_rst_n: input  logic,
    i_d    : input  logic,
    o_d    : output logic,
) {
    const a: u32 = $sv::pkg::paramA;
    //const b: u32 = pkg::paramA;

    inst u0: $sv::delay (
        i_clk    ,
        i_rst_n  ,
        i_d      ,
        o_d      ,
    );

    inst u1: $sv::delay (
        i_clk    ,
        i_rst_n  ,
        i_d      ,
        o_d      ,
    );
}
module Module43 {
    var a: $sv::StructA    ;
    var b: logic       <10>;

    assign b = a.memberA;
}
package Package44A {
    const z: u32 = 0;
}

package Package44B {
    const y: u32 = 0;
}

module Module44 {
    var a: logic<10>;
    var b: logic<10>;
    var c: logic<10>;

    import Package44A::z;
    import Package44B::*;

    assign a = Package44A::z;
    assign b = z;
    assign c = y;
}
module Module45 {
    let a: clock     = 1;
    var b: logic<10>;
    var c: logic<10>;

    always_ff (a) {
        var x: logic<10>;
        x = 1;
        b = x * 1;
    }

    always_comb {
        let y: logic<10> = 1;
        c = y * 1;
    }
}
module Module46 {
    let a: clock     = 1;
    var b: logic<10>;
    var c: logic<10>;
    var d: logic<10>;
    var e: logic<10>;

    always_ff (a) {
        d = 1;
        var x: logic<10>;
        x = 1;
        b = x * 1;
    }

    always_comb {
        e = 1;
        let y: logic<10> = 1;
        c = y * 1;
    }

    function FuncA (
        a: input  logic<10>,
        b: output logic<10>,
        c: ref    logic<10>,
    ) -> logic<10> {
        c = a / 1;
        var d: u32;
        d = 1;
        b = a + 1 + d;
        return a + 2;
    }

    function FuncB (
        a: input  logic<10>,
        b: output logic<10>,
        c: ref    logic<10>,
    ) -> logic<10> {
        c = a / 1;
        let d: u32 = 1;
        b = a + 1 + d;
        return a + 2;
    }
}
module Module47 {}

embed (inline) sv{{{
module test;
   initial begin
       $display("hello");
   end
endmodule
}}}

// comment
module Module48 {}

#[test(test1)]
embed (inline) sv{{{
module test1;
   initial begin
       $display("hello");
       assert(0) else $info("info");
       assert(0) else $warning("warning");
       assert(0) else $error("error");
       assert(0) else $fatal(1, "fatal");
       $finish();
   end
endmodule
}}}

#[test(test2)]
embed (inline) sv{{{
module test2;
    // parse error
    initial
endmodule
}}}

#[test(test3)]
embed (inline) sv{{{
module test3;
    // elaborate error
    tri logic a;
    always_comb a = 1;
endmodule
}}}

#[test(test4)]
module test4 {
    initial {
        $display("test4");
    }
}
module Module49 {
    var a: logic;

    always_comb {
        a = $acos();
        a = $acosh();
        a = $asin();
        a = $asinh();
        a = $assertcontrol();
        a = $assertfailoff();
        a = $assertfailon();
        a = $assertkill();
        a = $assertnonvacuouson();
        a = $assertoff();
        a = $asserton();
        a = $assertpassoff();
        a = $assertpasson();
        a = $assertvacuousoff();
        a = $async$and$array();
        a = $async$and$plane();
        a = $async$nand$array();
        a = $async$nand$plane();
        a = $async$nor$array();
        a = $async$nor$plane();
        a = $async$or$array();
        a = $async$or$plane();
        a = $atan();
        a = $atan2();
        a = $atanh();
        a = $bits();
        a = $bitstoreal();
        a = $bitstoshortreal();
        a = $cast();
        a = $ceil();
        a = $changed();
        a = $changed_gclk();
        a = $changing_gclk();
        a = $clog2();
        a = $cos();
        a = $cosh();
        a = $countbits();
        a = $countones();
        a = $coverage_control();
        a = $coverage_get();
        a = $coverage_get_max();
        a = $coverage_merge();
        a = $coverage_save();
        a = $dimensions();
        a = $display();
        a = $displayb();
        a = $displayh();
        a = $displayo();
        a = $dist_chi_square();
        a = $dist_erlang();
        a = $dist_exponential();
        a = $dist_normal();
        a = $dist_poisson();
        a = $dist_t();
        a = $dist_uniform();
        a = $dumpall();
        a = $dumpfile();
        a = $dumpflush();
        a = $dumplimit();
        a = $dumpoff();
        a = $dumpon();
        a = $dumpports();
        a = $dumpportsall();
        a = $dumpportsflush();
        a = $dumpportslimit();
        a = $dumpportsoff();
        a = $dumpportson();
        a = $dumpvars();
        a = $error();
        a = $exit();
        a = $exp();
        a = $falling_gclk();
        a = $fatal();
        a = $fclose();
        a = $fdisplay();
        a = $fdisplayb();
        a = $fdisplayh();
        a = $fdisplayo();
        a = $fell();
        a = $fell_gclk();
        a = $feof();
        a = $ferror();
        a = $fflush();
        a = $fgetc();
        a = $fgets();
        a = $finish();
        a = $floor();
        a = $fmonitor();
        a = $fmonitorb();
        a = $fmonitorh();
        a = $fmonitoro();
        a = $fopen();
        a = $fread();
        a = $fscanf();
        a = $fseek();
        a = $fstrobe();
        a = $fstrobeb();
        a = $fstrobeh();
        a = $fstrobeo();
        a = $ftell();
        a = $future_gclk();
        a = $fwrite();
        a = $fwriteb();
        a = $fwriteh();
        a = $fwriteo();
        a = $get_coverage();
        a = $high();
        a = $hypot();
        a = $increment();
        a = $info();
        a = $isunbounded();
        a = $isunknown();
        a = $itor();
        a = $left();
        a = $ln();
        a = $load_coverage_db();
        a = $log10();
        a = $low();
        a = $monitor();
        a = $monitorb();
        a = $monitorh();
        a = $monitoro();
        a = $monitoroff();
        a = $monitoron();
        a = $onehot();
        a = $onehot0();
        a = $past();
        a = $past_gclk();
        a = $pow();
        a = $printtimescale();
        a = $q_add();
        a = $q_exam();
        a = $q_full();
        a = $q_initialize();
        a = $q_remove();
        a = $random();
        a = $readmemb();
        a = $readmemh();
        a = $realtime();
        a = $realtobits();
        a = $rewind();
        a = $right();
        a = $rising_gclk();
        a = $rose();
        a = $rose_gclk();
        a = $rtoi();
        a = $sampled();
        a = $set_coverage_db_name();
        a = $sformat();
        a = $sformatf();
        a = $shortrealtobits();
        a = $signed();
        a = $sin();
        a = $sinh();
        a = $size();
        a = $sqrt();
        a = $sscanf();
        a = $stable();
        a = $stable_gclk();
        a = $steady_gclk();
        a = $stime();
        a = $stop();
        a = $strobe();
        a = $strobeb();
        a = $strobeh();
        a = $strobeo();
        a = $swrite();
        a = $swriteb();
        a = $swriteh();
        a = $swriteo();
        a = $sync$and$array();
        a = $sync$and$plane();
        a = $sync$nand$array();
        a = $sync$nand$plane();
        a = $sync$nor$array();
        a = $sync$nor$plane();
        a = $sync$or$array();
        a = $sync$or$plane();
        a = $system();
        a = $tan();
        a = $tanh();
        a = $test$plusargs();
        a = $time();
        a = $timeformat();
        a = $typename();
        a = $ungetc();
        a = $unpacked_dimensions();
        a = $unsigned();
        a = $value$plusargs();
        a = $warning();
        a = $write();
        a = $writeb();
        a = $writeh();
        a = $writememb();
        a = $writememh();
        a = $writeo();
    }
}
package Package50 {
    enum EnumA: logic<1> {
        memberA,
        memberB,
    }
}

module Module50 {
    type EnumB = Package50::EnumA;

    let _a: Package50::EnumA = Package50::EnumA::memberA;
    let _b: EnumB            = EnumB::memberB;
}
module Module51 {
    let _a: logic [2] = '{1, 1,};
    let _b: logic [2] = '{1 repeat 2};
    let _c: logic [2] = '{default: 1};
}
module Module52 {}

include (inline, "52_include.sv");
module Module53 {
    enum EnumA: logic {
        A,
    }

    var _a: logic;
    always_comb {
        case EnumA::A {
            /*
            */
            EnumA::A: _a = 0;
            default : _a = 1;
        }
    }
}
module Module54 {
    function FuncA::<T: const> (
        a: input logic<T>,
    ) -> logic<T> {
        return a + 1;
    }

    let _a: logic<10> = FuncA::<10>(1);
    let _b: logic<10> = FuncA::<10>(1);
    let _c: logic<20> = FuncA::<20>(1);
    let _d: logic<20> = FuncA::<20>(1);

    function FuncB::<A: const, B: const = 2> (
        a: input logic<A + B>,
    ) -> logic<A + B> {
        return a + 1;
    }

    let _e: logic<12> = FuncB::<10>(1);
    let _f: logic<12> = FuncB::<10>(1);
    let _g: logic<14> = FuncB::<10, 4>(1);
    let _h: logic<14> = FuncB::<10, 4>(1);
}
module Module55 {
    inst u0: Module55A::<Module55B>;
    inst u1: Module55A::<Module55C>;
    inst u2: Module55E::<Module55C>;
    inst u3: Module55E::<Module55D>;
    inst u4: Module55F::<Module55C>;
    inst u5: Module55F::<>;
    inst u6: Module55H::<10>;
    inst u7: Module55H::<10>;
}

pub proto module Proto55;

/// Generic module test for doc comment
pub module Module55A::<T: Proto55> {
    inst u: T;
}

module Module55B for Proto55 {}

module Module55C for Proto55 {}

module Module55D for Proto55 {}

module Module55E::<T: Proto55> {
    inst u: Module55A::<T>;
}

module Module55F::<T: Proto55 = Module55B> {
    inst u: T;
}

module Module55G::<T: Proto55> {
    inst u: T;
}

module Module55H::<W: const> {
    struct StructH::<W: const> {
        value: logic<W>,
    }

    let _a: StructH::<W> = 0;
}
package Package56A {
    const X: u32 = 1;
}

package Package56B {
    const X: u32 = 2;
}

module Module56 {
    import Package56A::X;
    inst u0: Interface56A::<Package56A::X>;
    inst u1: Interface56A::<Package56B::X>;
    inst u2: Interface56B::<Package56A::X>;
    inst u3: Interface56B::<Package56A::X>;
    inst u4: Interface56B::<>;
    inst u5: Interface56B::<X>;
    inst u6: Module56Sub::<1>;

    let _a: logic = u0._a;
    let _b: logic = u2._b;
    let _c: logic = u5._b;
}

module Module56Sub::<T: const> {
    inst u: Interface56A::<T>;
    function f () {}
}

/// Generic interface test for doc comment
pub interface Interface56A::<T: const> {
    var _a: logic<T>;
}

/// Generic interface test for doc comment
pub interface Interface56B::<T: const = 3> {
    var _b: logic<T>;
}
/// Generic package test for doc comment
pub package Package57A::<T: const> {
    const X: u32 = T;
}

/// Generic package test for doc comment
pub package Package57B::<T: const = 4> {
    const X: u32 = T;
}

package Package57C::<W: const> {
    struct StructC {
        c: logic<W>,
    }
}

package Package57D {
    const Y: u32 = 1;
}

module Module57 {
    import Package57D::Y;
    const A: u32 = Package57A::<1>::X;
    const B: u64 = Package57A::<2>::X;
    const C: u32 = Package57B::<3>::X;
    const E: u32 = Package57B::<3>::X;
    const D: u64 = Package57B::<>::X;
    const F: u64 = Package57B::<Y>::X;

    var _e  : Package57C::<2>::StructC;
    assign _e.c = 1;
}
package Package58 {
    type B = u32;
    type C = u64;
}

module Module58 {
    struct StructA::<T: type> {
        A: T,
    }

    type C = i32;

    struct StructB::<T: type = C> {
        B: T,
    }

    struct StructC::<T: type, U: type> {
        B: T,
        C: U,
    }

    var _a: StructA::<Package58::B>;
    var _b: StructA::<Package58::C>;
    var _c: StructA::<C>           ;
    var _d: StructB::<Package58::C>;
    var _f: StructB::<Package58::C>;
    var _e: StructB::<>            ;
    var _g: StructC::<C, C>        ;
}
package Package59A {
    const XLEN: u32 = 32;
}

package Package59B {
    const XLEN: u32 = Package59A::XLEN;
}
pub module Module60A (
    i_clk_a: input  `a clock,
    i_rst_a: input  `a reset,
    i_dat_a: input  `a logic,
    o_dat_a: output `a logic,
    i_clk_b: input  `b clock,
    i_rst_b: input  `b reset,
    i_dat_b: input  `b logic,
    o_dat_b: output `b logic,
) {
    assign o_dat_a = i_dat_a;
    assign o_dat_b = i_dat_b;
}

pub module Module60B (
    i_clk   : input  `_ clock,
    i_clk_x2: input  `_ clock,
    i_dat   : input     logic,
    o_dat   : output    logic,
) {
    assign o_dat = i_dat;
}

pub module Module60C (
    i_clk: input     clock,
    i_dat: input     logic,
    o_dat: output    logic,
    i_thr: input  `a logic,
    o_thr: output `a logic,
) {
    assign o_dat = i_dat;
    assign o_thr = i_thr;
}
module Module61A (
    i_dat: input  `a logic,
    o_dat: output `b logic,
) {
    unsafe (cdc) {
        assign o_dat = i_dat;
    }
}

module Module61B (
    i_clk: input  `b clock,
    i_dat: input  `a logic,
    o_dat: output `b logic,
) {
    unsafe (cdc) {
        inst u_sync: $sv::Synchronizer (
            c: i_clk,
            d: i_dat,
            q: o_dat,
        );
    }
}
module Module62 {
    var r#clock: logic;
    var r#reset: logic;
    let r#in   : logic = 0;
    var r#out  : logic;
    assign r#clock = 1;
    assign r#reset = 1;
    assign r#out   = r#in;
}
module Module63 (
    i_clk   : input clock,
    i_rst   : input reset,
    i_data_a: input logic,
) {
    inst u: Module63A (
        i_clk     ,
        i_rst     ,
        i_data_a  ,
    );

    var a: logic;

    always_ff {
        if_reset {
            a = 0;
        } else {
            a = 1;
        }
    }

    let _b: logic = i_rst;
}

module Module63A (
    i_clk   : input clock,
    i_rst   : input reset,
    i_data_a: input logic,
) {}
module Module64 {
    let a: u32 = 1;

    let _x0: u32 = a as u32;
    let _x1: u64 = a as u64;
    let _x2: i32 = a as i32;
    let _x3: i64 = a as i64;
    let _x4: f32 = a as f32;
    let _x5: f64 = a as f64;
}
module Module65 {
    let a: `_ clock            = 1;
    let b: `_ reset            = 1;
    let c: `_ reset_async_high = 1;
    let d: `_ reset_async_low  = 1;
    let e: `_ reset_sync_high  = 1;
    let f: `_ reset_sync_low   = 1;

    let _x0: `_ clock_posedge    = a as clock_posedge;
    let _x1: `_ clock_negedge    = a as clock_negedge;
    let _x2: `_ reset_async_high = b as reset_async_high;
    let _x3: `_ reset_async_low  = b as reset_async_low;
    let _x4: `_ reset_sync_high  = b as reset_sync_high;
    let _x5: `_ reset_sync_low   = b as reset_sync_low;
    let _x6: `_ reset            = c as reset;
    let _x7: `_ reset            = d as reset;
    let _x8: `_ reset            = e as reset;
    let _x9: `_ reset            = f as reset;
}
interface Interface66 {
    var en: logic;

    modport port {
        en: output,
    }
}

module Module66 (
    a: modport Interface66::port,
    b: interface,
    c: interface::port,
) {

    inst u: Module66A (
        a: a,
        b: b,
        c: c,
    );
}

module Module66A (
    a: modport Interface66::port,
    b: interface,
    c: interface::port,
) {}
module Module67 (
    i_clk: input  clock,
    i_d  : input  logic,
    o_d  : output logic,
) {

    always_ff {
        o_d = i_d;
    }
}

#[test(test67A, Module67)]
embed (cocotb) py{{{
import random

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge
from cocotb.types import LogicArray

@cocotb.test()
async def test(dut):
    #assert LogicArray(dut.o_d.value) == LogicArray("X")
    dut.i_d.value = 0
    clock = Clock(dut.i_clk, 10, units="us")
    cocotb.start_soon(clock.start(start_high=False))
    await RisingEdge(dut.i_clk)
    expected_val = 0
    for i in range(10):
        val = random.randint(0, 1)
        dut.i_d.value = val
        await RisingEdge(dut.i_clk)
        assert dut.o_d.value == expected_val, f"output q was incorrect on the {i}th cycle"
        expected_val = val
    await RisingEdge(dut.i_clk)
    assert dut.o_d.value == expected_val, "output q was incorrect on the last cycle"
}}}

#[test(test67B, Module67)]
include (cocotb, "67_cocotb.py");
module Module68 (
    i_clk : input  clock   ,
    i_rst : input  reset   ,
    i_push: input  logic   ,
    i_data: input  logic<8>,
    i_pop : input  logic   ,
    o_data: output logic<8>,
) {
    inst u: $std::fifo (
        i_clk            ,
        i_rst            ,
        i_clear      : '0,
        o_empty      : _ ,
        o_almost_full: _ ,
        o_full       : _ ,
        o_word_count : _ ,
        i_push           ,
        i_data           ,
        i_pop            ,
        o_data           ,
    );
}
module Module69::<T: Proto69> {
    inst u: T (
        a: 0,
        b: 0,
        c: _,
    );
}

proto module Proto69 #(
    param A: u32 = 1,
    param B: u32 = 1,
    param C: u32 = 1,
) (
    a: input  logic,
    b: input  logic,
    c: output logic,
);

module Module69A for Proto69 #(
    param A: u32 = 1,
    param B: u32 = 1,
    param C: u32 = 1,
) (
    a: input  logic,
    b: input  logic,
    c: output logic,
) {
    assign c = a;
}
interface Interface70A {
    var en: logic;

    modport port {
        en: output,
    }
}

interface Interface70B::<WIDTH: const> {
    var value: logic<WIDTH>;

    modport port {
        value: output,
    }
}

module Module70 (
    c: interface,
) {
    inst a: Interface70A;
    inst b: Interface70B::<8>;

    inst u: Module70A (
        a: a,
        b: b,
        c: c,
    );
}

module Module70A (
    a: modport Interface70A::port     ,
    b: modport Interface70B::<8>::port,
    c: interface,
) {}
module Module71 #(
    param param_type: type = logic,
) {
    type type_type = logic<32>;

    struct struct_type {
        a: logic,
    }

    inst m: Module71A #(T1: param_type, T2: type_type, T3: struct_type, T4: logic<10>,);
}

module Module71A #(
    param T1: type = logic,
    param T2: type = logic,
    param T3: type = logic,
    param T4: type = logic,
) {}
module Module72 (
    i_clk: input clock,
    i_rst: input reset,
) {
    let x: logic = 1;
    var a: logic;
    var b: logic;
    var c: logic;
    var d: logic;
    var e: logic;
    var f: logic;
    var g: logic;
    var h: logic;
    var i: logic;

    always_comb {
        #[cond_type(unique)]
        case x {
            0: a = 1;
            1: a = 1;
        }
        #[cond_type(unique0)]
        case x {
            0: b = 1;
            1: b = 1;
        }
        #[cond_type(priority)]
        case x {
            0: c = 1;
            1: c = 1;
        }
    }

    always_comb {
        #[cond_type(unique)]
        if x == 0 {
            d = 1;
        } else if x == 1 {
            d = 1;
        }
        #[cond_type(unique0)]
        if x == 0 {
            e = 1;
        } else if x == 1 {
            e = 1;
        }
        #[cond_type(priority)]
        if x == 0 {
            f = 1;
        } else if x == 1 {
            f = 1;
        }
    }

    always_ff {
        #[cond_type(unique)]
        if_reset {
            g = 1;
        } else if x == 1 {
            g = 1;
        }
    }
    always_ff {
        #[cond_type(unique0)]
        if_reset {
            h = 1;
        } else if x == 1 {
            h = 1;
        }
    }
    always_ff {
        #[cond_type(priority)]
        if_reset {
            i = 1;
        } else if x == 1 {
            i = 1;
        }
    }
}
package Package73 {
    const A: bit = 0;
}

module Module73A::<B: const> (
    i_a: input  logic = Package73::A,
    i_b: input  logic = B           ,
    i_c: input  logic = 0           ,
    o_d: output logic = _           ,
) {
    assign o_d = 0;
}

module Module73B {
    inst u0: Module73A::<0>;
    inst u1: Module73A::<1>;
    inst u2: Module73A::<1> (
        i_a: 0,
        i_b: 0,
    );
}

module Module73C {
    function FuncC::<B: const> (
        i_a: input logic = Package73::A,
        i_b: input logic = B           ,
        i_c: input logic = 1           ,
    ) {}

    always_comb {
        FuncC::<0>();
        FuncC::<1>();
        FuncC::<1>(0, 0);
    }
}

module Module73D {
    function FuncD::<B: const> (
        i_a: input logic = Package73::A,
        i_b: input logic = B           ,
        i_c: input logic = 1           ,
    ) -> bit {
        return 0;
    }

    var _d: bit;
    var _e: bit;
    var _f: bit;

    always_comb {
        _d = FuncD::<0>();
        _e = FuncD::<1>();
        _f = FuncD::<1>(0, 0);
    }
}
module fifo_controller #(
    param TYPE         : type = logic,
    param DEPTH        : u32  = 8    ,
    param THRESHOLD    : u32  = DEPTH,
    param FLAG_FF_OUT  : bit  = 1    ,
    param DATA_FF_OUT  : bit  = 1    ,
    param PUSH_ON_CLEAR: bit  = 0    ,
    param RAM_WORDS    : u32  = if DATA_FF_OUT {
        DEPTH - 1
    } else {
        DEPTH
    },
    param RAM_POINTER_WIDTH: u32 = if RAM_WORDS >= 2 {
        $clog2(RAM_WORDS)
    } else {
        1
    },
    param MATCH_COUNT_WIDTH: u32 = 0                                             ,
    param POINTER_WIDTH    : u32 = if DEPTH >= 2 {
        $clog2(DEPTH)
    } else {
        1
    },
    const RAM_POINTER: type = logic<RAM_POINTER_WIDTH>              ,
    const POINTER    : type = logic<POINTER_WIDTH>                  ,
    const COUNTER    : type = logic<$clog2(DEPTH + 1)>              ,
) (
    i_clk          : input  clock      ,
    i_rst          : input  reset      ,
    i_clear        : input  logic      ,
    o_empty        : output logic      ,
    o_almost_full  : output logic      ,
    o_full         : output logic      ,
    o_word_count   : output COUNTER    ,
    i_push         : input  logic      ,
    i_data         : input  TYPE       ,
    i_pop          : input  logic      ,
    o_write_pointer: output RAM_POINTER,
    o_write_to_ff  : output logic      ,
    o_write_to_ram : output logic      ,
    o_read_pointer : output RAM_POINTER,
    o_read_from_ram: output logic      ,
) {
    struct s_status_flag {
        empty      : logic,
        almost_full: logic,
        full       : logic,
    }

    var push             : logic           ;
    var pop              : logic           ;
    var clear            : logic        <2>;
    var update_state     : logic           ;
    var word_counter     : COUNTER         ;
    var word_counter_next: COUNTER         ;
    var word_counter_eq_1: logic           ;
    var word_counter_eq_2: logic           ;
    var word_counter_ge_2: logic           ;
    var status_flag      : s_status_flag   ;
    var write_to_ff      : logic           ;
    var write_to_ram     : logic           ;
    var ram_write_pointer: RAM_POINTER     ;
    var read_from_ram    : logic           ;
    var ram_read_pointer : RAM_POINTER     ;
    var ram_empty_next   : logic           ;
    var match_data       : logic           ;
    var last_pop_data    : logic           ;

    always_comb {
        push = i_push && ((PUSH_ON_CLEAR && i_clear) || ((!status_flag.full) && (!match_data)));
        pop  = i_pop && (!status_flag.empty) && last_pop_data;
    }

    always_comb {
        clear[0] = i_clear && ((!PUSH_ON_CLEAR) || (!push));
        clear[1] = i_clear && PUSH_ON_CLEAR && push;
    }

    always_comb {
        update_state = push || pop || i_clear;
    }

    //--------------------------------------------------------------
    //  word counter
    //--------------------------------------------------------------
    always_comb {
        o_word_count = word_counter;
    }

    always_comb {
        word_counter_eq_1 = (DEPTH >= 1) && (word_counter == 1 as COUNTER);
        word_counter_eq_2 = (DEPTH >= 2) && (word_counter == 2 as COUNTER);
        word_counter_ge_2 = (DEPTH >= 2) && (word_counter >= 2 as COUNTER);
    }

    always_comb {
        word_counter_next = get_word_counter_next(push, pop, clear, word_counter);
    }

    always_ff {
        if_reset {
            word_counter = '0;
        } else if update_state {
            word_counter = word_counter_next;
        }
    }

    function get_word_counter_next (
        push        : input logic     ,
        pop         : input logic     ,
        clear       : input logic  <2>,
        word_counter: input COUNTER   ,
    ) -> COUNTER {
        var up  : logic;
        var down: logic;
        up   = push && (!pop);
        down = (!push) && pop;
        switch {
            clear[0]: return 0 as COUNTER;
            clear[1]: return 1 as COUNTER;
            up      : return word_counter + 1 as COUNTER;
            down    : return word_counter - 1 as COUNTER;
            default : return word_counter;
        }
    }

    //--------------------------------------------------------------
    //  status flag
    //--------------------------------------------------------------
    always_comb {
        o_empty       = status_flag.empty;
        o_almost_full = status_flag.almost_full;
        o_full        = status_flag.full && (!match_data);
    }

    if FLAG_FF_OUT :g_flag_ff_out {
        always_ff {
            if_reset {
                status_flag.empty       = '1;
                status_flag.almost_full = '0;
                status_flag.full        = '0;
            } else if update_state {
                status_flag = get_status_flag(word_counter_next);
            }
        }
    } else :g_flag_logic_out {
        always_comb {
            status_flag = get_status_flag(word_counter);
        }
    }

    function get_status_flag (
        word_count: input COUNTER,
    ) -> s_status_flag {
        var flag            : s_status_flag;
        flag.empty       = word_count == 0;
        flag.almost_full = word_count >= THRESHOLD;
        flag.full        = word_count >= DEPTH;
        return flag;
    }

    //--------------------------------------------------------------
    //  write/read pointer
    //--------------------------------------------------------------
    always_comb {
        o_write_pointer = ram_write_pointer;
        o_write_to_ff   = write_to_ff;
        o_write_to_ram  = write_to_ram;
        o_read_pointer  = ram_read_pointer;
        o_read_from_ram = read_from_ram;
    }

    if DATA_FF_OUT :g_data_ff_out {
        always_comb {
            if (word_counter_eq_1 && pop) || status_flag.empty || clear[1] {
                write_to_ff  = push;
                write_to_ram = '0;
            } else {
                write_to_ff  = '0;
                write_to_ram = push;
            }
            read_from_ram  = pop && word_counter_ge_2;
            ram_empty_next = read_from_ram && (!write_to_ram) && word_counter_eq_2;
        }
    } else :g_data_ram_out {
        always_comb {
            write_to_ff    = '0;
            write_to_ram   = push;
            read_from_ram  = pop;
            ram_empty_next = read_from_ram && (!write_to_ram) && word_counter_eq_1;
        }
    }

    if RAM_WORDS >= 2 :g_multi_word_ram {
        always_ff {
            if_reset {
                ram_write_pointer = 0 as RAM_POINTER;
            } else if (clear[0]) {
                ram_write_pointer = 0 as RAM_POINTER;
            } else if (clear[1]) {
                ram_write_pointer = if DATA_FF_OUT {
                    0 as RAM_POINTER
                } else {
                    1 as RAM_POINTER
                };
            } else if (ram_empty_next) {
                ram_write_pointer = ram_read_pointer;
            } else if (write_to_ram) {
                if (ram_write_pointer == (RAM_WORDS - 1) as RAM_POINTER) {
                    ram_write_pointer = 0 as RAM_POINTER;
                } else {
                    ram_write_pointer += 1 as RAM_POINTER;
                }
            }
        }

        always_ff {
            if_reset {
                ram_read_pointer = 0 as RAM_POINTER;
            } else if (i_clear) {
                ram_read_pointer = 0 as RAM_POINTER;
            } else if (ram_empty_next) {
                ram_read_pointer = ram_read_pointer;
            } else if (read_from_ram) {
                if (ram_read_pointer == (RAM_WORDS - 1) as RAM_POINTER) {
                    ram_read_pointer = 0 as RAM_POINTER;
                } else {
                    ram_read_pointer += 1 as RAM_POINTER;
                }
            }
        }
    } else :g_single_word_ram {
        always_comb {
            ram_write_pointer = 0 as RAM_POINTER;
            ram_read_pointer  = 0 as RAM_POINTER;
        }
    }

    //--------------------------------------------------------------
    //  data match
    //--------------------------------------------------------------
    if MATCH_COUNT_WIDTH >: 0 :g_data_match {
        var match_count     : logic  <DEPTH, MATCH_COUNT_WIDTH>;
        var match_count_full: logic  <DEPTH>                   ;
        var match_count_eq_1: logic  <DEPTH>                   ;
        var last_match_data : logic  <DEPTH>                   ;
        var write_pointer   : POINTER<2>                       ;
        var read_pointer    : POINTER                          ;
        var data            : TYPE                             ;

        if DEPTH == RAM_WORDS :g_pointer {
            always_comb {
                write_pointer[0] = ram_write_pointer;
                read_pointer     = ram_read_pointer;
            }
        } else {
            always_ff {
                if_reset {
                    write_pointer[0] = 0 as POINTER;
                } else if clear[0] {
                    write_pointer[0] = 0 as POINTER;
                } else if clear[1] {
                    write_pointer[0] = 1 as POINTER;
                } else if push {
                    if write_pointer[0] == (DEPTH - 1) as POINTER {
                        write_pointer[0] = 0 as POINTER;
                    } else {
                        write_pointer[0] += 1 as POINTER;
                    }
                }
            }

            always_ff {
                if_reset {
                    read_pointer = 0 as POINTER;
                } else if i_clear {
                    read_pointer = 0 as POINTER;
                } else if pop {
                    if read_pointer == (DEPTH - 1) as POINTER {
                        read_pointer = 0 as POINTER;
                    } else {
                        read_pointer += 1 as POINTER;
                    }
                }
            }
        }

        always_comb {
            if write_pointer[0] == 0 as POINTER {
                write_pointer[1] = (DEPTH - 1) as POINTER;
            } else {
                write_pointer[1] = write_pointer[0] - 1 as POINTER;
            }
        }

        always_ff {
            if push {
                data = i_data;
            }
        }

        always_comb {
            match_data    = (!status_flag.empty) && (i_data == data) && (!match_count_full[write_pointer[1]]);
            last_pop_data = last_match_data[read_pointer];
        }

        for i in 0..DEPTH :g_match_count {
            var up_down: logic<3>;

            always_comb {
                match_count_full[i] = match_count[i] == '1;
                match_count_eq_1[i] = match_count[i] == 1 as MATCH_COUNT_WIDTH;
                last_match_data[i]  = match_count_eq_1[i] && (up_down[2:1] == '0);
            }

            always_comb {
                up_down[2] = (match_data == '0) && (write_pointer[0] == i as POINTER) && push;
                up_down[1] = (match_data == '1) && (write_pointer[1] == i as POINTER) && i_push;
                up_down[0] = (!status_flag.empty) && (read_pointer == i as POINTER) && i_pop;
            }

            always_ff {
                if_reset {
                    match_count[i] = 0 as MATCH_COUNT_WIDTH;
                } else if clear[0] || (i_clear && (i >= 1)) {
                    match_count[i] = 0 as MATCH_COUNT_WIDTH;
                } else if clear[1] && (i == 0) {
                    match_count[i] = 1 as MATCH_COUNT_WIDTH;
                } else if inside up_down {3'b1x0, 3'bx10} {
                    match_count[i] += 1 as MATCH_COUNT_WIDTH;
                } else if up_down == 3'b001 {
                    match_count[i] -= 1 as MATCH_COUNT_WIDTH;
                }
            }
        }
    } else :g {
        always_comb {
            match_data    = '0;
            last_pop_data = '1;
        }
    }
}
